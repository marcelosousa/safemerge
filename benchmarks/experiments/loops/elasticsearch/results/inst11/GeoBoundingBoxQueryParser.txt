Parsing files...
Merge Instance for method (Ident "GeoBoundingBoxQueryParser",Ident "parse",[RefType (ClassRefType (ClassType [(Ident "QueryParseContext",[])]))])
@Override
 public Query parse (QueryParseContext parseContext) throws IOException, QueryParsingException
{
  XContentParser parser = parseContext.parser();
  String fieldName = null;
  double top = Double.NaN;
  double bottom = Double.NaN;
  double left = Double.NaN;
  double right = Double.NaN;
  <?HOLE?>
  String queryName = null;
  String currentFieldName = null;
  XContentParser.Token token;
  boolean normalize = true;
  GeoPoint sparse = new GeoPoint();
  String type = "memory";
  while (token = parser.nextToken() != XContentParser.Token.END_OBJECT)
  {
    if (token == XContentParser.Token.FIELD_NAME)
    {
      currentFieldName = parser.currentName();
    }
    else
      if (token == XContentParser.Token.START_OBJECT)
      {
        fieldName = currentFieldName;
        while (token = parser.nextToken() != XContentParser.Token.END_OBJECT)
        {
          if (token == XContentParser.Token.FIELD_NAME)
          {
            currentFieldName = parser.currentName();
            token = parser.nextToken();
            if (parseContext.isDeprecatedSetting(currentFieldName))
            {
            }
            else
              if (FIELD.equals(currentFieldName))
              {
                fieldName = parser.text();
              }
              else
                if (TOP.equals(currentFieldName))
                {
                  top = parser.doubleValue();
                }
                else
                  if (BOTTOM.equals(currentFieldName))
                  {
                    bottom = parser.doubleValue();
                  }
                  else
                    if (LEFT.equals(currentFieldName))
                    {
                      left = parser.doubleValue();
                    }
                    else
                      if (RIGHT.equals(currentFieldName))
                      {
                        right = parser.doubleValue();
                      }
                      else
                      {
                        if (TOP_LEFT.equals(currentFieldName) || TOPLEFT.equals(currentFieldName))
                        {
                          GeoUtils.parseGeoPoint(parser, sparse);
                          top = sparse.getLat();
                          left = sparse.getLon();
                        }
                        else
                          if (BOTTOM_RIGHT.equals(currentFieldName) || BOTTOMRIGHT.equals(currentFieldName))
                          {
                            GeoUtils.parseGeoPoint(parser, sparse);
                            bottom = sparse.getLat();
                            right = sparse.getLon();
                          }
                          else
                            if (TOP_RIGHT.equals(currentFieldName) || TOPRIGHT.equals(currentFieldName))
                            {
                              GeoUtils.parseGeoPoint(parser, sparse);
                              top = sparse.getLat();
                              right = sparse.getLon();
                            }
                            else
                              if (BOTTOM_LEFT.equals(currentFieldName) || BOTTOMLEFT.equals(currentFieldName))
                              {
                                GeoUtils.parseGeoPoint(parser, sparse);
                                bottom = sparse.getLat();
                                left = sparse.getLon();
                              }
                              else
                              {
                                throw new ElasticsearchParseException("failed to parse [{}] query. unexpected field [{}]", NAME, currentFieldName);
                              }
                      }
          }
          else
          {
            throw new ElasticsearchParseException("failed to parse [{}] query. field name expected but [{}] found", NAME, token);
          }
        }
      }
      else
        if (token.isValue())
        {
          if ("_name".equals(currentFieldName))
          {
            queryName = parser.text();
          }
          else
            <?HOLE?>
        }
  }
  final GeoPoint topLeft = sparse.reset(top, left);
  final GeoPoint bottomRight = new GeoPoint(bottom, right);
  if (normalize)
  {
    boolean completeLonRange = ((right - left) % 360 == 0 && right) > left;
    GeoUtils.normalizePoint(topLeft, true, (!completeLonRange));
    GeoUtils.normalizePoint(bottomRight, true, (!completeLonRange));
    if (completeLonRange)
    {
      topLeft.resetLon((-180));
      bottomRight.resetLon(180);
    }
  }
  MappedFieldType fieldType = parseContext.fieldMapper(fieldName);
  if (fieldType == null)
  {
    throw new QueryParsingException(parseContext, "failed to parse [{}] query. could not find [{}] field [{}]", NAME, GeoPointFieldMapper.CONTENT_TYPE, fieldName);
  }
  if (!(fieldType instanceof GeoPointFieldMapper.GeoPointFieldType))
  {
    <?HOLE?>
  }
  GeoPointFieldMapper.GeoPointFieldType geoFieldType = (GeoPointFieldMapper.GeoPointFieldType) fieldType;
  Query filter;
  if ("indexed".equals(type))
  {
    filter = IndexedGeoBoundingBoxQuery.create(topLeft, bottomRight, geoFieldType);
  }
  else
    if ("memory".equals(type))
    {
      IndexGeoPointFieldData indexFieldData = parseContext.getForField(fieldType);
      filter = new InMemoryGeoBoundingBoxQuery(topLeft, bottomRight, indexFieldData);
    }
    else
    {
      throw new QueryParsingException(parseContext, "failed to parse [{}] query. geo bounding box type [{}] is not supported. either [indexed] or [memory] are allowed", NAME, type);
    }
  <?HOLE?>
  if (queryName != null)
  {
    parseContext.addNamedQuery(queryName, filter);
  }
  return filter;
}
Edit Base:
Hole 1:
[]: <SKIP>
Hole 2:
[SCond,SCond,SCond,SCond,SCond,SLoop]: if ("normalize".equals(currentFieldName))
{
  normalize = parser.booleanValue();
}
else
  if ("type".equals(currentFieldName))
  {
    type = parser.text();
  }
  else
  {
    throw new QueryParsingException(parseContext, "failed to parse [{}] query. unexpected field [{}]", NAME, currentFieldName);
  }
Hole 3:
[SCond]: throw new QueryParsingException(parseContext, "failed to parse [{}] query. field [{}] is expected to be of type [{}], but is of [{}] type instead", NAME, fieldName, GeoPointFieldMapper.CONTENT_TYPE, fieldType.names().shortName());
Hole 4:
[]: <SKIP>

Edit A:
Hole 1:
[]: float boost = AbstractQueryBuilder.DEFAULT_BOOST;
Hole 2:
[SCond,SCond,SCond,SCond,SCond,SLoop]: if ("boost".equals(currentFieldName))
{
  boost = parser.floatValue();
}
else
  if ("normalize".equals(currentFieldName))
  {
    normalize = parser.booleanValue();
  }
  else
    if ("type".equals(currentFieldName))
    {
      type = parser.text();
    }
    else
    {
      throw new QueryParsingException(parseContext, "failed to parse [{}] query. unexpected field [{}]", NAME, currentFieldName);
    }
Hole 3:
[SCond]: throw new QueryParsingException(parseContext, "failed to parse [{}] query. field [{}] is expected to be of type [{}], but is of [{}] type instead", NAME, fieldName, GeoPointFieldMapper.CONTENT_TYPE, fieldType.names().shortName());
Hole 4:
[]: if (filter != null)
{
  filter.setBoost(boost);
}

Edit B:
Hole 1:
[]: <SKIP>
Hole 2:
[SCond,SCond,SCond,SCond,SLoop]: if ("normalize".equals(currentFieldName))
{
  normalize = parser.booleanValue();
}
else
  if ("type".equals(currentFieldName))
  {
    type = parser.text();
  }
  else
  {
    throw new QueryParsingException(parseContext, "failed to parse [{}] query. unexpected field [{}]", NAME, currentFieldName);
  }
Hole 3:
[SCond]: throw new QueryParsingException(parseContext, "failed to parse [{}] query. field [{}] is expected to be of type [{}], but is of [{}] type instead", NAME, fieldName, GeoPointFieldMapper.CONTENT_TYPE, fieldType.typeName());
Hole 4:
[]: <SKIP>

Edit M:
Hole 1:
[]: float boost = AbstractQueryBuilder.DEFAULT_BOOST;
Hole 2:
[SCond,SCond,SCond,SCond,SLoop]: if ("boost".equals(currentFieldName))
{
  boost = parser.floatValue();
}
else
  if ("normalize".equals(currentFieldName))
  {
    normalize = parser.booleanValue();
  }
  else
    if ("type".equals(currentFieldName))
    {
      type = parser.text();
    }
    else
    {
      throw new QueryParsingException(parseContext, "failed to parse [{}] query. unexpected field [{}]", NAME, currentFieldName);
    }
Hole 3:
[SCond]: throw new QueryParsingException(parseContext, "failed to parse [{}] query. field [{}] is expected to be of type [{}], but is of [{}] type instead", NAME, fieldName, GeoPointFieldMapper.CONTENT_TYPE, fieldType.typeName());
Hole 4:
[]: if (filter != null)
{
  filter.setBoost(boost);
}


