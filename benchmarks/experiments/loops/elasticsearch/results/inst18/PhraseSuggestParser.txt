Parsing files...
Merge Instance for method (Ident "PhraseSuggestParser",Ident "parse",[RefType (ClassRefType (ClassType [(Ident "XContentParser",[])])),RefType (ClassRefType (ClassType [(Ident "MapperService",[])])),RefType (ClassRefType (ClassType [(Ident "IndexQueryParserService",[])]))])
@Override
 public SuggestionSearchContext.SuggestionContext parse (XContentParser parser, MapperService mapperService, IndexQueryParserService queryParserService) throws IOException
{
  PhraseSuggestionContext suggestion = new PhraseSuggestionContext(suggester);
  suggestion.setQueryParserService(queryParserService);
  XContentParser.Token token;
  String fieldName = null;
  boolean gramSizeSet = false;
  while (token = parser.nextToken() != XContentParser.Token.END_OBJECT)
  {
    if (token == XContentParser.Token.FIELD_NAME)
    {
      fieldName = parser.currentName();
    }
    else
      if (token.isValue())
      {
        if (!SuggestUtils.parseSuggestContext(parser, mapperService, fieldName, suggestion))
        {
          if ("real_word_error_likelihood".equals(fieldName) || "realWorldErrorLikelihood".equals(fieldName))
          {
            suggestion.setRealWordErrorLikelihood(parser.floatValue());
            if (suggestion.realworldErrorLikelyhood() <= 0.0)
            {
              throw new IllegalArgumentException("real_word_error_likelihood must be > 0.0");
            }
          }
          else
            if ("confidence".equals(fieldName))
            {
              suggestion.setConfidence(parser.floatValue());
              if (suggestion.confidence() < 0.0)
              {
                throw new IllegalArgumentException("confidence must be >= 0.0");
              }
            }
            else
              if ("separator".equals(fieldName))
              {
                suggestion.setSeparator(new BytesRef(parser.text()));
              }
              else
                if ("max_errors".equals(fieldName) || "maxErrors".equals(fieldName))
                {
                  suggestion.setMaxErrors(parser.floatValue());
                  if (suggestion.maxErrors() <= 0.0)
                  {
                    throw new IllegalArgumentException("max_error must be > 0.0");
                  }
                }
                else
                  if ("gram_size".equals(fieldName) || "gramSize".equals(fieldName))
                  {
                    suggestion.setGramSize(parser.intValue());
                    if (suggestion.gramSize() < 1)
                    {
                      throw new IllegalArgumentException("gram_size must be >= 1");
                    }
                    gramSizeSet = true;
                  }
                  else
                    if ("force_unigrams".equals(fieldName) || "forceUnigrams".equals(fieldName))
                    {
                      suggestion.setRequireUnigram(parser.booleanValue());
                    }
                    else
                      if ("token_limit".equals(fieldName) || "tokenLimit".equals(fieldName))
                      {
                        int tokenLimit = parser.intValue();
                        if (tokenLimit <= 0)
                        {
                          throw new IllegalArgumentException("token_limit must be >= 1");
                        }
                        suggestion.setTokenLimit(tokenLimit);
                      }
                      else
                      {
                        throw new IllegalArgumentException("suggester[phrase] doesn't support field [" + fieldName + "]");
                      }
        }
      }
      else
        if (token == Token.START_ARRAY)
        {
          if ("direct_generator".equals(fieldName) || "directGenerator".equals(fieldName))
          {
            while (token = parser.nextToken() == Token.START_OBJECT)
            {
              PhraseSuggestionContext.DirectCandidateGenerator generator = new PhraseSuggestionContext.DirectCandidateGenerator();
              while (token = parser.nextToken() != Token.END_OBJECT)
              {
                if (token == XContentParser.Token.FIELD_NAME)
                {
                  fieldName = parser.currentName();
                }
                if (token.isValue())
                {
                  parseCandidateGenerator(parser, mapperService, fieldName, generator);
                }
              }
              verifyGenerator(generator);
              suggestion.addGenerator(generator);
            }
          }
          else
          {
            throw new IllegalArgumentException("suggester[phrase]  doesn't support array field [" + fieldName + "]");
          }
        }
        else
          if (token == Token.START_OBJECT)
          {
            if ("smoothing".equals(fieldName))
            {
              parseSmoothingModel(parser, suggestion, fieldName);
            }
            else
              if ("highlight".equals(fieldName))
              {
                while (token = parser.nextToken() != XContentParser.Token.END_OBJECT)
                {
                  if (token == XContentParser.Token.FIELD_NAME)
                  {
                    fieldName = parser.currentName();
                  }
                  else
                    if (token.isValue())
                    {
                      if ("pre_tag".equals(fieldName) || "preTag".equals(fieldName))
                      {
                        suggestion.setPreTag(parser.utf8Bytes());
                      }
                      else
                        if ("post_tag".equals(fieldName) || "postTag".equals(fieldName))
                        {
                          suggestion.setPostTag(parser.utf8Bytes());
                        }
                        else
                        {
                          throw new IllegalArgumentException("suggester[phrase][highlight] doesn't support field [" + fieldName + "]");
                        }
                    }
                }
              }
              else
                if ("collate".equals(fieldName))
                {
                  while (token = parser.nextToken() != XContentParser.Token.END_OBJECT)
                  {
                    if (token == XContentParser.Token.FIELD_NAME)
                    {
                      fieldName = parser.currentName();
                    }
                    else
                      <?HOLE?>
                  }
                }
                else
                {
                  throw new IllegalArgumentException("suggester[phrase]  doesn't support array field [" + fieldName + "]");
                }
          }
          else
          {
            throw new IllegalArgumentException("suggester[phrase] doesn't support field [" + fieldName + "]");
          }
  }
  if (suggestion.getField() == null)
  {
    throw new IllegalArgumentException("The required field option is missing");
  }
  FieldMapper fieldMapper = mapperService.smartNameFieldMapper(suggestion.getField());
  if (fieldMapper == null)
  {
    throw new IllegalArgumentException("No mapping found for field [" + suggestion.getField() + "]");
  }
  else
    if (suggestion.getAnalyzer() == null)
    {
      <?HOLE?>
    }
  if (suggestion.model() == null)
  {
    suggestion.setModel(StupidBackoffScorer.FACTORY);
  }
  if (!gramSizeSet || suggestion.generators().isEmpty())
  {
    final ShingleTokenFilterFactory.Factory shingleFilterFactory = SuggestUtils.getShingleFilterFactory(suggestion.getAnalyzer());
    if (!gramSizeSet)
    {
      if (shingleFilterFactory != null)
      {
        suggestion.setGramSize(shingleFilterFactory.getMaxShingleSize());
        if ((suggestion.getAnalyzer() == null && shingleFilterFactory.getMinShingleSize()) > 1 && !shingleFilterFactory.getOutputUnigrams())
        {
          throw new IllegalArgumentException("The default analyzer for field: [" + suggestion.getField() + "] doesn't emit unigrams. If this is intentional try to set the analyzer explicitly");
        }
      }
    }
    if (suggestion.generators().isEmpty())
    {
      if ((shingleFilterFactory != null && shingleFilterFactory.getMinShingleSize()) > 1 && !shingleFilterFactory.getOutputUnigrams() && suggestion.getRequireUnigram())
      {
        throw new IllegalArgumentException("The default candidate generator for phrase suggest can't operate on field: [" + suggestion.getField() + "] since it doesn't emit unigrams. If this is intentional try to set the candidate generator field explicitly");
      }
      DirectCandidateGenerator generator = new DirectCandidateGenerator();
      generator.setField(suggestion.getField());
      suggestion.addGenerator(generator);
    }
  }
  return suggestion;
}
Edit Base:
Hole 1:
[SCond,SCond,SLoop,SCond,SCond,SCond,SCond,SCond,SCond,SCond,SLoop]: if ("query".equals(fieldName) || "filter".equals(fieldName))
{
  String templateNameOrTemplateContent;
  if (token == XContentParser.Token.START_OBJECT)
  {
    XContentBuilder builder = XContentBuilder.builder(parser.contentType().xContent());
    builder.copyCurrentStructure(parser);
    templateNameOrTemplateContent = builder.string();
  }
  else
  {
    templateNameOrTemplateContent = parser.text();
  }
  if (templateNameOrTemplateContent == null)
  {
    throw new IllegalArgumentException("suggester[phrase][collate] no query/filter found in collate object");
  }
  if (suggestion.getCollateFilterScript() != null)
  {
    throw new IllegalArgumentException("suggester[phrase][collate] filter already set, doesn't support additional [" + fieldName + "]");
  }
  if (suggestion.getCollateQueryScript() != null)
  {
    throw new IllegalArgumentException("suggester[phrase][collate] query already set, doesn't support additional [" + fieldName + "]");
  }
  CompiledScript compiledScript = suggester.scriptService().compile(new Script(MustacheScriptEngineService.NAME, templateNameOrTemplateContent, ScriptType.INLINE, null), ScriptContext.Standard.SEARCH);
  if ("query".equals(fieldName))
  {
    suggestion.setCollateQueryScript(compiledScript);
  }
  else
  {
    suggestion.setCollateFilterScript(compiledScript);
  }
}
else
  if ("params".equals(fieldName))
  {
    suggestion.setCollateScriptParams(parser.map());
  }
  else
    if ("prune".equals(fieldName))
    {
      if (parser.isBooleanValue())
      {
        suggestion.setCollatePrune(parser.booleanValue());
      }
      else
      {
        throw new IllegalArgumentException("suggester[phrase][collate] prune must be either 'true' or 'false'");
      }
    }
    else
    {
      throw new IllegalArgumentException("suggester[phrase][collate] doesn't support field [" + fieldName + "]");
    }
Hole 2:
[SCond,SCond,SCond]: if (fieldMapper.searchAnalyzer() == null)
{
  suggestion.setAnalyzer(mapperService.searchAnalyzer());
}
else
{
  suggestion.setAnalyzer(fieldMapper.searchAnalyzer());
}

Edit A:
Hole 1:
[SCond,SCond,SLoop,SCond,SCond,SCond,SCond,SCond,SCond,SCond,SLoop]: if ("query".equals(fieldName) || "filter".equals(fieldName))
{
  String templateNameOrTemplateContent;
  if (token == XContentParser.Token.START_OBJECT)
  {
    XContentBuilder builder = XContentBuilder.builder(parser.contentType().xContent());
    builder.copyCurrentStructure(parser);
    templateNameOrTemplateContent = builder.string();
  }
  else
  {
    templateNameOrTemplateContent = parser.text();
  }
  if (templateNameOrTemplateContent == null)
  {
    throw new IllegalArgumentException("suggester[phrase][collate] no query/filter found in collate object");
  }
  if (suggestion.getCollateFilterScript() != null)
  {
    throw new IllegalArgumentException("suggester[phrase][collate] filter already set, doesn't support additional [" + fieldName + "]");
  }
  if (suggestion.getCollateQueryScript() != null)
  {
    throw new IllegalArgumentException("suggester[phrase][collate] query already set, doesn't support additional [" + fieldName + "]");
  }
  CompiledScript compiledScript = suggester.scriptService().compile(new Script(MustacheScriptEngineService.NAME, templateNameOrTemplateContent, ScriptType.INLINE, null), ScriptContext.Standard.SEARCH);
  if ("query".equals(fieldName))
  {
    suggestion.setCollateQueryScript(compiledScript);
  }
  else
  {
    suggestion.setCollateFilterScript(compiledScript);
  }
}
else
  if ("params".equals(fieldName))
  {
    suggestion.setCollateScriptParams(parser.map());
  }
  else
    if ("prune".equals(fieldName))
    {
      if (parser.isBooleanValue())
      {
        suggestion.setCollatePrune(parser.booleanValue());
      }
      else
      {
        throw new IllegalArgumentException("suggester[phrase][collate] prune must be either 'true' or 'false'");
      }
    }
    else
    {
      throw new IllegalArgumentException("suggester[phrase][collate] doesn't support field [" + fieldName + "]");
    }
Hole 2:
[SCond,SCond,SCond]: if (fieldMapper.fieldType().searchAnalyzer() == null)
{
  suggestion.setAnalyzer(mapperService.searchAnalyzer());
}
else
{
  suggestion.setAnalyzer(fieldMapper.fieldType().searchAnalyzer());
}

Edit B:
Hole 1:
[SCond,SCond,SLoop,SCond,SCond,SCond,SCond,SCond,SCond,SCond,SLoop]: if ("query".equals(fieldName))
{
  if (suggestion.getCollateQueryScript() != null)
  {
    throw new IllegalArgumentException("suggester[phrase][collate] query already set, doesn't support additional [" + fieldName + "]");
  }
  Template template = Template.parse(parser);
  CompiledScript compiledScript = suggester.scriptService().compile(template, ScriptContext.Standard.SEARCH);
  suggestion.setCollateQueryScript(compiledScript);
}
else
  if ("params".equals(fieldName))
  {
    suggestion.setCollateScriptParams(parser.map());
  }
  else
    if ("prune".equals(fieldName))
    {
      if (parser.isBooleanValue())
      {
        suggestion.setCollatePrune(parser.booleanValue());
      }
      else
      {
        throw new IllegalArgumentException("suggester[phrase][collate] prune must be either 'true' or 'false'");
      }
    }
    else
    {
      throw new IllegalArgumentException("suggester[phrase][collate] doesn't support field [" + fieldName + "]");
    }
Hole 2:
[SCond,SCond]: if (fieldMapper.searchAnalyzer() == null)
{
  suggestion.setAnalyzer(mapperService.searchAnalyzer());
}
else
{
  suggestion.setAnalyzer(fieldMapper.searchAnalyzer());
}

Edit M:
Hole 1:
[SCond,SLoop,SCond,SCond,SCond,SCond,SCond,SCond,SCond,SLoop]: if ("query".equals(fieldName))
{
  if (suggestion.getCollateQueryScript() != null)
  {
    throw new IllegalArgumentException("suggester[phrase][collate] query already set, doesn't support additional [" + fieldName + "]");
  }
  Template template = Template.parse(parser);
  CompiledScript compiledScript = suggester.scriptService().compile(template, ScriptContext.Standard.SEARCH);
  suggestion.setCollateQueryScript(compiledScript);
}
else
  if ("params".equals(fieldName))
  {
    suggestion.setCollateScriptParams(parser.map());
  }
  else
    if ("prune".equals(fieldName))
    {
      if (parser.isBooleanValue())
      {
        suggestion.setCollatePrune(parser.booleanValue());
      }
      else
      {
        throw new IllegalArgumentException("suggester[phrase][collate] prune must be either 'true' or 'false'");
      }
    }
    else
    {
      throw new IllegalArgumentException("suggester[phrase][collate] doesn't support field [" + fieldName + "]");
    }
Hole 2:
[SCond,SCond]: if (fieldMapper.fieldType().searchAnalyzer() == null)
{
  suggestion.setAnalyzer(mapperService.searchAnalyzer());
}
else
{
  suggestion.setAnalyzer(fieldMapper.fieldType().searchAnalyzer());
}


