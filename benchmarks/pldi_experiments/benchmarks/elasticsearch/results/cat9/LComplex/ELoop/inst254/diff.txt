Merge Instance for method (Ident "MatchQueryParser",Ident "parse",[RefType (ClassRefType (ClassType [(Ident "QueryParseContext",[])]))])
@Override
 public Query parse (QueryParseContext parseContext) throws IOException, QueryParsingException
{
  XContentParser parser = parseContext.parser();
  MatchQuery.Type type = MatchQuery.Type.BOOLEAN;
  if ("match_phrase".equals(parser.currentName()) || "matchPhrase".equals(parser.currentName()) || "text_phrase".equals(parser.currentName()) || "textPhrase".equals(parser.currentName()))
  {
    type = MatchQuery.Type.PHRASE;
  }
  else
    if ("match_phrase_prefix".equals(parser.currentName()) || "matchPhrasePrefix".equals(parser.currentName()) || "text_phrase_prefix".equals(parser.currentName()) || "textPhrasePrefix".equals(parser.currentName()))
    {
      type = MatchQuery.Type.PHRASE_PREFIX;
    }
  XContentParser.Token token = parser.nextToken();
  if (token != XContentParser.Token.FIELD_NAME)
  {
    throw new QueryParsingException(parseContext, "[match] query malformed, no field");
  }
  String fieldName = parser.currentName();
  Object value = null;
  <?HOLE?>
  MatchQuery matchQuery = new MatchQuery(parseContext);
  String minimumShouldMatch = null;
  String queryName = null;
  token = parser.nextToken();
  if (token == XContentParser.Token.START_OBJECT)
  {
    String currentFieldName = null;
    while (token = parser.nextToken() != XContentParser.Token.END_OBJECT)
    {
      if (token == XContentParser.Token.FIELD_NAME)
      {
        currentFieldName = parser.currentName();
      }
      else
        if (token.isValue())
        {
          if ("query".equals(currentFieldName))
          {
            value = parser.objectText();
          }
          else
            if ("type".equals(currentFieldName))
            {
              String tStr = parser.text();
              if ("boolean".equals(tStr))
              {
                type = MatchQuery.Type.BOOLEAN;
              }
              else
                if ("phrase".equals(tStr))
                {
                  type = MatchQuery.Type.PHRASE;
                }
                else
                  if ("phrase_prefix".equals(tStr) || "phrasePrefix".equals(currentFieldName))
                  {
                    type = MatchQuery.Type.PHRASE_PREFIX;
                  }
                  else
                  {
                    throw new QueryParsingException(parseContext, "[match] query does not support type " + tStr);
                  }
            }
            else
              if ("analyzer".equals(currentFieldName))
              {
                String analyzer = parser.text();
                if (parseContext.analysisService().analyzer(analyzer) == null)
                {
                  throw new QueryParsingException(parseContext, "[match] analyzer [" + parser.text() + "] not found");
                }
                matchQuery.setAnalyzer(analyzer);
              }
              else
                if ("boost".equals(currentFieldName))
                {
                  boost = parser.floatValue();
                }
                else
                  if ("slop".equals(currentFieldName) || "phrase_slop".equals(currentFieldName) || "phraseSlop".equals(currentFieldName))
                  {
                    matchQuery.setPhraseSlop(parser.intValue());
                  }
                  else
                    if (parseContext.parseFieldMatcher().match(currentFieldName, Fuzziness.FIELD))
                    {
                      matchQuery.setFuzziness(Fuzziness.parse(parser));
                    }
                    else
                      if ("prefix_length".equals(currentFieldName) || "prefixLength".equals(currentFieldName))
                      {
                        matchQuery.setFuzzyPrefixLength(parser.intValue());
                      }
                      else
                        if ("max_expansions".equals(currentFieldName) || "maxExpansions".equals(currentFieldName))
                        {
                          matchQuery.setMaxExpansions(parser.intValue());
                        }
                        else
                          if ("operator".equals(currentFieldName))
                          {
                            <?HOLE?>
                            <?HOLE?>
                          }
                          else
                            if ("minimum_should_match".equals(currentFieldName) || "minimumShouldMatch".equals(currentFieldName))
                            {
                              minimumShouldMatch = parser.textOrNull();
                            }
                            else
                              <?HOLE?>
        }
    }
    parser.nextToken();
  }
  else
  {
    value = parser.objectText();
    token = parser.nextToken();
    if (token != XContentParser.Token.END_OBJECT)
    {
      throw new QueryParsingException(parseContext, "[match] query parsed in simplified form, with direct field name, but included more options than just the field name, possibly use its 'options' form, with 'query' element?");
    }
  }
  if (value == null)
  {
    throw new QueryParsingException(parseContext, "No text specified for text query");
  }
  Query query = matchQuery.parse(type, fieldName, value);
  if (query == null)
  {
    return null;
  }
  if (query instanceof BooleanQuery)
  {
    Queries.applyMinimumShouldMatch(((BooleanQuery) query), minimumShouldMatch);
  }
  else
    if (query instanceof ExtendedCommonTermsQuery)
    {
      ((ExtendedCommonTermsQuery) query).setLowFreqMinimumNumberShouldMatch(minimumShouldMatch);
    }
  query.setBoost(boost);
  if (queryName != null)
  {
    parseContext.addNamedQuery(queryName, query);
  }
  return query;
}
Edit Base:
Hole 1:
[]: float boost = 1.0F;
Hole 2:
[SCond,SCond,SCond,SCond,SCond,SCond,SCond,SCond,SCond,SCond,SCond,SLoop,SCond]: String op = parser.text();
Hole 3:
[SCond,SCond,SCond,SCond,SCond,SCond,SCond,SCond,SCond,SCond,SCond,SLoop,SCond]: if ("or".equalsIgnoreCase(op))
{
  matchQuery.setOccur(BooleanClause.Occur.SHOULD);
}
else
  if ("and".equalsIgnoreCase(op))
  {
    matchQuery.setOccur(BooleanClause.Occur.MUST);
  }
  else
  {
    throw new QueryParsingException(parseContext, "text query requires operator to be either 'and' or 'or', not [" + op + "]");
  }
Hole 4:
[SCond,SCond,SCond,SCond,SCond,SCond,SCond,SCond,SCond,SCond,SCond,SCond,SCond,SLoop,SCond]: if ("rewrite".equals(currentFieldName))
{
  matchQuery.setRewriteMethod(QueryParsers.parseRewriteMethod(parser.textOrNull(), null));
}
else
  if ("fuzzy_rewrite".equals(currentFieldName) || "fuzzyRewrite".equals(currentFieldName))
  {
    matchQuery.setFuzzyRewriteMethod(QueryParsers.parseRewriteMethod(parser.textOrNull(), null));
  }
  else
    if ("fuzzy_transpositions".equals(currentFieldName))
    {
      matchQuery.setTranspositions(parser.booleanValue());
    }
    else
      if ("lenient".equals(currentFieldName))
      {
        matchQuery.setLenient(parser.booleanValue());
      }
      else
        if ("cutoff_frequency".equals(currentFieldName))
        {
          matchQuery.setCommonTermsCutoff(parser.floatValue());
        }
        else
          if ("zero_terms_query".equals(currentFieldName))
          {
            String zeroTermsDocs = parser.text();
            if ("none".equalsIgnoreCase(zeroTermsDocs))
            {
              matchQuery.setZeroTermsQuery(MatchQuery.ZeroTermsQuery.NONE);
            }
            else
              if ("all".equalsIgnoreCase(zeroTermsDocs))
              {
                matchQuery.setZeroTermsQuery(MatchQuery.ZeroTermsQuery.ALL);
              }
              else
              {
                throw new QueryParsingException(parseContext, "Unsupported zero_terms_docs value [" + zeroTermsDocs + "]");
              }
          }
          else
            if ("_name".equals(currentFieldName))
            {
              queryName = parser.text();
            }
            else
            {
              throw new QueryParsingException(parseContext, "[match] query does not support [" + currentFieldName + "]");
            }

Edit A:
Hole 1:
[]: float boost = AbstractQueryBuilder.DEFAULT_BOOST;
Hole 2:
[SCond,SCond,SCond,SCond,SCond,SCond,SCond,SCond,SCond,SCond,SCond,SLoop,SCond]: matchQuery.setOccur(Operator.fromString(parser.text()).toBooleanClauseOccur());
Hole 3:
[SCond,SCond,SCond,SCond,SCond,SCond,SCond,SCond,SCond,SCond,SCond,SLoop,SCond]: <SKIP>
Hole 4:
[SCond,SCond,SCond,SCond,SCond,SCond,SCond,SCond,SCond,SCond,SCond,SCond,SCond,SLoop,SCond]: if ("rewrite".equals(currentFieldName))
{
  matchQuery.setRewriteMethod(QueryParsers.parseRewriteMethod(parser.textOrNull(), null));
}
else
  if ("fuzzy_rewrite".equals(currentFieldName) || "fuzzyRewrite".equals(currentFieldName))
  {
    matchQuery.setFuzzyRewriteMethod(QueryParsers.parseRewriteMethod(parser.textOrNull(), null));
  }
  else
    if ("fuzzy_transpositions".equals(currentFieldName))
    {
      matchQuery.setTranspositions(parser.booleanValue());
    }
    else
      if ("lenient".equals(currentFieldName))
      {
        matchQuery.setLenient(parser.booleanValue());
      }
      else
        if ("cutoff_frequency".equals(currentFieldName))
        {
          matchQuery.setCommonTermsCutoff(parser.floatValue());
        }
        else
          if ("zero_terms_query".equals(currentFieldName))
          {
            String zeroTermsDocs = parser.text();
            if ("none".equalsIgnoreCase(zeroTermsDocs))
            {
              matchQuery.setZeroTermsQuery(MatchQuery.ZeroTermsQuery.NONE);
            }
            else
              if ("all".equalsIgnoreCase(zeroTermsDocs))
              {
                matchQuery.setZeroTermsQuery(MatchQuery.ZeroTermsQuery.ALL);
              }
              else
              {
                throw new QueryParsingException(parseContext, "Unsupported zero_terms_docs value [" + zeroTermsDocs + "]");
              }
          }
          else
            if ("_name".equals(currentFieldName))
            {
              queryName = parser.text();
            }
            else
            {
              throw new QueryParsingException(parseContext, "[match] query does not support [" + currentFieldName + "]");
            }

Edit B:
Hole 1:
[]: float boost = 1.0F;
Hole 2:
[SCond,SCond,SCond,SCond,SCond,SCond,SCond,SCond,SCond,SCond,SCond,SLoop,SCond]: String op = parser.text();
Hole 3:
[SCond,SCond,SCond,SCond,SCond,SCond,SCond,SCond,SCond,SCond,SCond,SLoop,SCond]: if ("or".equalsIgnoreCase(op))
{
  matchQuery.setOccur(BooleanClause.Occur.SHOULD);
}
else
  if ("and".equalsIgnoreCase(op))
  {
    matchQuery.setOccur(BooleanClause.Occur.MUST);
  }
  else
  {
    throw new QueryParsingException(parseContext, "text query requires operator to be either 'and' or 'or', not [" + op + "]");
  }
Hole 4:
[SCond,SCond,SCond,SCond,SCond,SCond,SCond,SCond,SCond,SCond,SCond,SCond,SCond,SLoop,SCond]: if ("fuzzy_rewrite".equals(currentFieldName) || "fuzzyRewrite".equals(currentFieldName))
{
  matchQuery.setFuzzyRewriteMethod(QueryParsers.parseRewriteMethod(parseContext.parseFieldMatcher(), parser.textOrNull(), null));
}
else
  if ("fuzzy_transpositions".equals(currentFieldName))
  {
    matchQuery.setTranspositions(parser.booleanValue());
  }
  else
    if ("lenient".equals(currentFieldName))
    {
      matchQuery.setLenient(parser.booleanValue());
    }
    else
      if ("cutoff_frequency".equals(currentFieldName))
      {
        matchQuery.setCommonTermsCutoff(parser.floatValue());
      }
      else
        if ("zero_terms_query".equals(currentFieldName))
        {
          String zeroTermsDocs = parser.text();
          if ("none".equalsIgnoreCase(zeroTermsDocs))
          {
            matchQuery.setZeroTermsQuery(MatchQuery.ZeroTermsQuery.NONE);
          }
          else
            if ("all".equalsIgnoreCase(zeroTermsDocs))
            {
              matchQuery.setZeroTermsQuery(MatchQuery.ZeroTermsQuery.ALL);
            }
            else
            {
              throw new QueryParsingException(parseContext, "Unsupported zero_terms_docs value [" + zeroTermsDocs + "]");
            }
        }
        else
          if ("_name".equals(currentFieldName))
          {
            queryName = parser.text();
          }
          else
          {
            throw new QueryParsingException(parseContext, "[match] query does not support [" + currentFieldName + "]");
          }

Edit M:
Hole 1:
[]: float boost = AbstractQueryBuilder.DEFAULT_BOOST;
Hole 2:
[SCond,SCond,SCond,SCond,SCond,SCond,SCond,SCond,SCond,SCond,SCond,SLoop,SCond]: matchQuery.setOccur(Operator.fromString(parser.text()).toBooleanClauseOccur());
Hole 3:
[SCond,SCond,SCond,SCond,SCond,SCond,SCond,SCond,SCond,SCond,SCond,SLoop,SCond]: <SKIP>
Hole 4:
[SCond,SCond,SCond,SCond,SCond,SCond,SCond,SCond,SCond,SCond,SCond,SCond,SLoop,SCond]: if ("fuzzy_rewrite".equals(currentFieldName) || "fuzzyRewrite".equals(currentFieldName))
{
  matchQuery.setFuzzyRewriteMethod(QueryParsers.parseRewriteMethod(parseContext.parseFieldMatcher(), parser.textOrNull(), null));
}
else
  if ("fuzzy_transpositions".equals(currentFieldName))
  {
    matchQuery.setTranspositions(parser.booleanValue());
  }
  else
    if ("lenient".equals(currentFieldName))
    {
      matchQuery.setLenient(parser.booleanValue());
    }
    else
      if ("cutoff_frequency".equals(currentFieldName))
      {
        matchQuery.setCommonTermsCutoff(parser.floatValue());
      }
      else
        if ("zero_terms_query".equals(currentFieldName))
        {
          String zeroTermsDocs = parser.text();
          if ("none".equalsIgnoreCase(zeroTermsDocs))
          {
            matchQuery.setZeroTermsQuery(MatchQuery.ZeroTermsQuery.NONE);
          }
          else
            if ("all".equalsIgnoreCase(zeroTermsDocs))
            {
              matchQuery.setZeroTermsQuery(MatchQuery.ZeroTermsQuery.ALL);
            }
            else
            {
              throw new QueryParsingException(parseContext, "Unsupported zero_terms_docs value [" + zeroTermsDocs + "]");
            }
        }
        else
          if ("_name".equals(currentFieldName))
          {
            queryName = parser.text();
          }
          else
          {
            throw new QueryParsingException(parseContext, "[match] query does not support [" + currentFieldName + "]");
          }

