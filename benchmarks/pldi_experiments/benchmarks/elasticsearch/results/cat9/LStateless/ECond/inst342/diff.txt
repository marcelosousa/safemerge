Merge Instance for method (Ident "RecoveryFromGatewayTests",Ident "testReusePeerRecovery",[])
@Test
 @Slow
 @TestLogging("gateway:TRACE,indices.recovery:TRACE,index.engine:TRACE")
 public void testReusePeerRecovery () throws Exception
{
  final Settings settings = settingsBuilder().put("action.admin.cluster.node.shutdown.delay", "10ms").put(MockFSDirectoryService.CHECK_INDEX_ON_CLOSE, false).put("gateway.recover_after_nodes", 4).put(ThrottlingAllocationDecider.CLUSTER_ROUTING_ALLOCATION_CONCURRENT_RECOVERIES, 4).put(MockFSDirectoryService.CRASH_INDEX, false).build();
  internalCluster().startNodesAsync(4, settings).get();
  <?HOLE?>
  ensureGreen();
  logger.info("--> indexing docs");
  for (int i = 0 ; i < 1000 ; i++)
  {
    client().prepareIndex("test", "type").setSource("field", "value").execute().actionGet();
    if (i % 200 == 0)
    {
      client().admin().indices().prepareFlush().execute().actionGet();
    }
  }
  if (randomBoolean())
  {
    client().admin().indices().prepareFlush().execute().actionGet();
  }
  logger.info("Running Cluster Health");
  ensureGreen();
  client().admin().indices().prepareOptimize("test").setMaxNumSegments(100).get();
  client().admin().indices().prepareFlush().setWaitIfOngoing(true).setForce(true).get();
  boolean useSyncIds = randomBoolean();
  if (useSyncIds == false)
  {
    logger.info("--> disabling allocation while the cluster is shut down");
    client().admin().cluster().prepareUpdateSettings().setTransientSettings(settingsBuilder().put(EnableAllocationDecider.CLUSTER_ROUTING_ALLOCATION_ENABLE, EnableAllocationDecider.Allocation.NONE)).get();
    logger.info("--> full cluster restart");
    internalCluster().fullRestart();
    logger.info("--> waiting for cluster to return to green after first shutdown");
    ensureGreen();
  }
  else
  {
    logger.info("--> trying to sync flush");
    <?HOLE?>
    <?HOLE?>
    <?HOLE?>
    assertSyncIdsNotNull();
  }
  logger.info("--> disabling allocation while the cluster is shut down", (useSyncIds ? "" : " a second time"));
  client().admin().cluster().prepareUpdateSettings().setTransientSettings(settingsBuilder().put(EnableAllocationDecider.CLUSTER_ROUTING_ALLOCATION_ENABLE, EnableAllocationDecider.Allocation.NONE)).get();
  logger.info("--> full cluster restart");
  internalCluster().fullRestart();
  logger.info("--> waiting for cluster to return to green after {}shutdown", (useSyncIds ? "" : "second "));
  ensureGreen();
  if (useSyncIds)
  {
    assertSyncIdsNotNull();
  }
  RecoveryResponse recoveryResponse = client().admin().indices().prepareRecoveries("test").get();
  for (ShardRecoveryResponse response : recoveryResponse.shardResponses().get("test")) {
                                                                                         RecoveryState recoveryState = response.recoveryState();
                                                                                         long recovered = 0;
                                                                                         for (RecoveryState.File file : recoveryState.getIndex().fileDetails()) {
                                                                                                                                                                  if (file.name().startsWith("segments"))
                                                                                                                                                                  {
                                                                                                                                                                    recovered += file.length();
                                                                                                                                                                  }
                                                                                                                                                                }
                                                                                         if (!recoveryState.getPrimary() && useSyncIds == false)
                                                                                         {
                                                                                           logger.info("--> replica shard {} recovered from {} to {}, recovered {}, reuse {}", response.getShardId(), recoveryState.getSourceNode().name(), recoveryState.getTargetNode().name(), recoveryState.getIndex().recoveredBytes(), recoveryState.getIndex().reusedBytes());
                                                                                           assertThat("no bytes should be recovered", recoveryState.getIndex().recoveredBytes(), equalTo(recovered));
                                                                                           assertThat("data should have been reused", recoveryState.getIndex().reusedBytes(), greaterThan(0L));
                                                                                           assertThat("all bytes should be reused except of the segments file", recoveryState.getIndex().reusedBytes(), equalTo((recoveryState.getIndex().totalBytes() - recovered)));
                                                                                           assertThat("no files should be recovered except of the segments file", recoveryState.getIndex().recoveredFileCount(), equalTo(1));
                                                                                           assertThat("all files should be reused except of the segments file", recoveryState.getIndex().reusedFileCount(), equalTo((recoveryState.getIndex().totalFileCount() - 1)));
                                                                                           assertThat("> 0 files should be reused", recoveryState.getIndex().reusedFileCount(), greaterThan(0));
                                                                                         }
                                                                                         else
                                                                                         {
                                                                                           if (useSyncIds && !recoveryState.getPrimary())
                                                                                           {
                                                                                             logger.info("--> replica shard {} recovered from {} to {} using sync id, recovered {}, reuse {}", response.getShardId(), recoveryState.getSourceNode().name(), recoveryState.getTargetNode().name(), recoveryState.getIndex().recoveredBytes(), recoveryState.getIndex().reusedBytes());
                                                                                           }
                                                                                           assertThat(recoveryState.getIndex().recoveredBytes(), equalTo(0L));
                                                                                           assertThat(recoveryState.getIndex().reusedBytes(), equalTo(recoveryState.getIndex().totalBytes()));
                                                                                           assertThat(recoveryState.getIndex().recoveredFileCount(), equalTo(0));
                                                                                           assertThat(recoveryState.getIndex().reusedFileCount(), equalTo(recoveryState.getIndex().totalFileCount()));
                                                                                         }
                                                                                       }
}
Edit Base:
Hole 1:
[]: assertAcked(prepareCreate("test").setSettings(ImmutableSettings.builder().put(indexSettings()).put(EnableAllocationDecider.INDEX_ROUTING_REBALANCE_ENABLE, EnableAllocationDecider.Rebalance.NONE)));
Hole 2:
[SCond]: int numShards = Integer.parseInt(client().admin().indices().prepareGetSettings("test").get().getSetting("test", "index.number_of_shards"));
Hole 3:
[SCond]: SyncedFlushService syncedFlushService = internalCluster().getInstance(SyncedFlushService.class);
Hole 4:
[SCond]: for (int i = 0 ; i < numShards ; i++)
{
  assertTrue(SyncedFlushUtil.attemptSyncedFlush(syncedFlushService, new ShardId("test", i)).success());
}

Edit A:
Hole 1:
[]: assertAcked(prepareCreate("test").setSettings(Settings.builder().put(indexSettings()).put(EnableAllocationDecider.INDEX_ROUTING_REBALANCE_ENABLE, EnableAllocationDecider.Rebalance.NONE)));
Hole 2:
[SCond]: int numShards = Integer.parseInt(client().admin().indices().prepareGetSettings("test").get().getSetting("test", "index.number_of_shards"));
Hole 3:
[SCond]: SyncedFlushService syncedFlushService = internalCluster().getInstance(SyncedFlushService.class);
Hole 4:
[SCond]: for (int i = 0 ; i < numShards ; i++)
{
  assertTrue(SyncedFlushUtil.attemptSyncedFlush(syncedFlushService, new ShardId("test", i)).success());
}

Edit B:
Hole 1:
[]: assertAcked(prepareCreate("test").setSettings(ImmutableSettings.builder().put(indexSettings()).put(EnableAllocationDecider.INDEX_ROUTING_REBALANCE_ENABLE, EnableAllocationDecider.Rebalance.NONE)));
Hole 2:
[SCond]: assertEquals(SyncedFlushUtil.attemptSyncedFlush(internalCluster(), "test").failedShards(), 0);
Hole 3:
[SCond]: <SKIP>
Hole 4:
[SCond]: <SKIP>

Edit M:
Hole 1:
[]: assertAcked(prepareCreate("test").setSettings(Settings.builder().put(indexSettings()).put(EnableAllocationDecider.INDEX_ROUTING_REBALANCE_ENABLE, EnableAllocationDecider.Rebalance.NONE)));
Hole 2:
[SCond]: assertEquals(SyncedFlushUtil.attemptSyncedFlush(internalCluster(), "test").failedShards(), 0);
Hole 3:
[SCond]: <SKIP>
Hole 4:
[SCond]: <SKIP>

