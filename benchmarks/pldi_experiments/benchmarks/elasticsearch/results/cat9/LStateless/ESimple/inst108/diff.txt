Merge Instance for method (Ident "DiskThresholdDeciderUnitTests",Ident "testCanRemainUsesLeastAvailableSpace",[])
public void testCanRemainUsesLeastAvailableSpace ()
{
  NodeSettingsService nss = new NodeSettingsService(Settings.EMPTY);
  ClusterInfoService cis = EmptyClusterInfoService.INSTANCE;
  DiskThresholdDecider decider = new DiskThresholdDecider(Settings.EMPTY, nss, cis, null);
  ImmutableOpenMap.Builder<ShardRouting, String> shardRoutingMap = ImmutableOpenMap.builder();
  DiscoveryNode node_0 = new DiscoveryNode("node_0", DummyTransportAddress.INSTANCE, Version.CURRENT);
  DiscoveryNode node_1 = new DiscoveryNode("node_1", DummyTransportAddress.INSTANCE, Version.CURRENT);
  <?HOLE?>
  ShardRoutingHelper.initialize(test_0, node_0.getId());
  ShardRoutingHelper.moveToStarted(test_0);
  shardRoutingMap.put(test_0, "/node0/least");
  <?HOLE?>
  ShardRoutingHelper.initialize(test_1, node_1.getId());
  ShardRoutingHelper.moveToStarted(test_1);
  shardRoutingMap.put(test_1, "/node1/least");
  <?HOLE?>
  ShardRoutingHelper.initialize(test_2, node_1.getId());
  ShardRoutingHelper.moveToStarted(test_2);
  shardRoutingMap.put(test_2, "/node1/most");
  <?HOLE?>
  ShardRoutingHelper.initialize(test_3, node_1.getId());
  ShardRoutingHelper.moveToStarted(test_3);
  MetaData metaData = MetaData.builder().put(IndexMetaData.builder("test").settings(settings(Version.CURRENT)).numberOfShards(1).numberOfReplicas(1)).build();
  RoutingTable routingTable = RoutingTable.builder().addAsNew(metaData.index("test")).build();
  ClusterState clusterState = ClusterState.builder(org.elasticsearch.cluster.ClusterName.DEFAULT).metaData(metaData).routingTable(routingTable).build();
  logger.info("--> adding two nodes");
  clusterState = ClusterState.builder(clusterState).nodes(DiscoveryNodes.builder().put(node_0).put(node_1)).build();
  ImmutableOpenMap.Builder<String, DiskUsage> leastAvailableUsages = ImmutableOpenMap.builder();
  leastAvailableUsages.put("node_0", new DiskUsage("node_0", "node_0", "/node0/least", 100, 10));
  leastAvailableUsages.put("node_1", new DiskUsage("node_1", "node_1", "/node1/least", 100, 9));
  ImmutableOpenMap.Builder<String, DiskUsage> mostAvailableUsage = ImmutableOpenMap.builder();
  mostAvailableUsage.put("node_0", new DiskUsage("node_0", "node_0", "/node0/most", 100, 90));
  mostAvailableUsage.put("node_1", new DiskUsage("node_1", "node_1", "/node1/most", 100, 90));
  ImmutableOpenMap.Builder<String, Long> shardSizes = ImmutableOpenMap.builder();
  shardSizes.put("[test][0][p]", 10L);
  shardSizes.put("[test][1][p]", 10L);
  shardSizes.put("[test][2][p]", 10L);
  final ClusterInfo clusterInfo = new ClusterInfo(leastAvailableUsages.build(), mostAvailableUsage.build(), shardSizes.build(), shardRoutingMap.build());
  <?HOLE?>
  assertEquals(Decision.YES, decider.canRemain(test_0, new RoutingNode("node_0", node_0), allocation));
  assertEquals(Decision.NO, decider.canRemain(test_1, new RoutingNode("node_1", node_1), allocation));
  try
  {
    decider.canRemain(test_0, new RoutingNode("node_1", node_1), allocation);
    fail("not allocated on this node");
  }
  catch (IllegalArgumentException ex)
  {
  }
  try
  {
    decider.canRemain(test_1, new RoutingNode("node_0", node_0), allocation);
    fail("not allocated on this node");
  }
  catch (IllegalArgumentException ex)
  {
  }
  assertEquals("can stay since allocated on a different path with enough space", Decision.YES, decider.canRemain(test_2, new RoutingNode("node_1", node_1), allocation));
  assertEquals("can stay since we don't have information about this shard", Decision.YES, decider.canRemain(test_2, new RoutingNode("node_1", node_1), allocation));
}
Edit Base:
Hole 1:
[]: ShardRouting test_0 = ShardRouting.newUnassigned("test", 0, null, true, new UnassignedInfo(UnassignedInfo.Reason.INDEX_CREATED, "foo"));
Hole 2:
[]: ShardRouting test_1 = ShardRouting.newUnassigned("test", 1, null, true, new UnassignedInfo(UnassignedInfo.Reason.INDEX_CREATED, "foo"));
Hole 3:
[]: ShardRouting test_2 = ShardRouting.newUnassigned("test", 2, null, true, new UnassignedInfo(UnassignedInfo.Reason.INDEX_CREATED, "foo"));
Hole 4:
[]: ShardRouting test_3 = ShardRouting.newUnassigned("test", 3, null, true, new UnassignedInfo(UnassignedInfo.Reason.INDEX_CREATED, "foo"));
Hole 5:
[]: RoutingAllocation allocation = new RoutingAllocation(new AllocationDeciders(Settings.EMPTY, new AllocationDecider[] {
                                                                                                                      decider,
                                                                                                                    }), clusterState.getRoutingNodes(), clusterState.nodes(), clusterInfo);

Edit A:
Hole 1:
[]: ShardRouting test_0 = ShardRouting.newUnassigned("test", 0, null, 1, true, new UnassignedInfo(UnassignedInfo.Reason.INDEX_CREATED, "foo"));
Hole 2:
[]: ShardRouting test_1 = ShardRouting.newUnassigned("test", 1, null, 1, true, new UnassignedInfo(UnassignedInfo.Reason.INDEX_CREATED, "foo"));
Hole 3:
[]: ShardRouting test_2 = ShardRouting.newUnassigned("test", 2, null, 1, true, new UnassignedInfo(UnassignedInfo.Reason.INDEX_CREATED, "foo"));
Hole 4:
[]: ShardRouting test_3 = ShardRouting.newUnassigned("test", 3, null, 1, true, new UnassignedInfo(UnassignedInfo.Reason.INDEX_CREATED, "foo"));
Hole 5:
[]: RoutingAllocation allocation = new RoutingAllocation(new AllocationDeciders(Settings.EMPTY, new AllocationDecider[] {
                                                                                                                      decider,
                                                                                                                    }), clusterState.getRoutingNodes(), clusterState.nodes(), clusterInfo);

Edit B:
Hole 1:
[]: ShardRouting test_0 = ShardRouting.newUnassigned("test", 0, null, true, new UnassignedInfo(UnassignedInfo.Reason.INDEX_CREATED, "foo"));
Hole 2:
[]: ShardRouting test_1 = ShardRouting.newUnassigned("test", 1, null, true, new UnassignedInfo(UnassignedInfo.Reason.INDEX_CREATED, "foo"));
Hole 3:
[]: ShardRouting test_2 = ShardRouting.newUnassigned("test", 2, null, true, new UnassignedInfo(UnassignedInfo.Reason.INDEX_CREATED, "foo"));
Hole 4:
[]: ShardRouting test_3 = ShardRouting.newUnassigned("test", 3, null, true, new UnassignedInfo(UnassignedInfo.Reason.INDEX_CREATED, "foo"));
Hole 5:
[]: RoutingAllocation allocation = new RoutingAllocation(new AllocationDeciders(Settings.EMPTY, new AllocationDecider[] {
                                                                                                                      decider,
                                                                                                                    }), clusterState.getRoutingNodes(), clusterState.nodes(), clusterInfo, System.nanoTime());

Edit M:
Hole 1:
[]: ShardRouting test_0 = ShardRouting.newUnassigned("test", 0, null, 1, true, new UnassignedInfo(UnassignedInfo.Reason.INDEX_CREATED, "foo"));
Hole 2:
[]: ShardRouting test_1 = ShardRouting.newUnassigned("test", 1, null, 1, true, new UnassignedInfo(UnassignedInfo.Reason.INDEX_CREATED, "foo"));
Hole 3:
[]: ShardRouting test_2 = ShardRouting.newUnassigned("test", 2, null, 1, true, new UnassignedInfo(UnassignedInfo.Reason.INDEX_CREATED, "foo"));
Hole 4:
[]: ShardRouting test_3 = ShardRouting.newUnassigned("test", 3, null, 1, true, new UnassignedInfo(UnassignedInfo.Reason.INDEX_CREATED, "foo"));
Hole 5:
[]: RoutingAllocation allocation = new RoutingAllocation(new AllocationDeciders(Settings.EMPTY, new AllocationDecider[] {
                                                                                                                      decider,
                                                                                                                    }), clusterState.getRoutingNodes(), clusterState.nodes(), clusterInfo, System.nanoTime());

