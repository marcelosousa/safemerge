Merge Instance for method (Ident "JetChangeSignatureUsageProcessor",Ident "findConflicts",[RefType (ClassRefType (ClassType [(Ident "ChangeInfo",[])])),RefType (ClassRefType (ClassType [(Ident "Ref",[ActualType (ArrayType (RefType (ClassRefType (ClassType [(Ident "UsageInfo",[])]))))])]))])
@Override
 public MultiMap<PsiElement, String> findConflicts (ChangeInfo info, Ref<UsageInfo[]> refUsages)
{
  MultiMap<PsiElement, String> result = new MultiMap<PsiElement, String>();
  UsageInfo[] usageInfos = refUsages.get();
  <?HOLE?>
  List<UsageInfo> adjustedUsages = KotlinPackage.filterNot(usageInfos, new Function1<UsageInfo, Boolean>()
                                                                       {
                                                                         @Override
                                                                         public Boolean invoke (UsageInfo info)
                                                                         {
                                                                           return (getOverriderOrCaller(info) instanceof KotlinLightMethod);
                                                                         }
                                                                       });
  if (adjustedUsages.size() < usageInfos.length)
  {
    refUsages.set(adjustedUsages.toArray(new UsageInfo[adjustedUsages.size()]));
  }
  if (!(info instanceof JetChangeInfo))
    return result;
  Set<String> parameterNames = new HashSet<String>();
  JetChangeInfo changeInfo = (JetChangeInfo) info;
  PsiElement function = info.getMethod();
  PsiElement element = function != null ? function : changeInfo.getContext();
  BindingContext bindingContext = ResolvePackage.analyze(((JetElement) element), BodyResolveMode.FULL);
  CallableDescriptor oldDescriptor = ChangeSignaturePackage.getOriginalBaseFunctionDescriptor(changeInfo);
  DeclarationDescriptor containingDeclaration = oldDescriptor.getContainingDeclaration();
  JetScope parametersScope = null;
  if ((oldDescriptor instanceof ConstructorDescriptor && containingDeclaration) instanceof ClassDescriptorWithResolutionScopes)
    parametersScope = ((ClassDescriptorWithResolutionScopes) containingDeclaration).getScopeForInitializerResolution();
  else
    if (function instanceof JetFunction)
      parametersScope = org.jetbrains.kotlin.idea.refactoring.RefactoringPackage.getBodyScope(((JetFunction) function), bindingContext);
  JetScope callableScope = org.jetbrains.kotlin.idea.refactoring.RefactoringPackage.getContainingScope(oldDescriptor, bindingContext);
  JetMethodDescriptor.Kind kind = ChangeSignaturePackage.getKind(changeInfo);
  if ((!kind.getIsConstructor() && callableScope) != null && !info.getNewName().isEmpty())
  {
    Name newName = Name.identifier(info.getNewName());
    <?HOLE?>
    for (CallableDescriptor conflict : conflicts) {
                                                    if (conflict == oldDescriptor)
                                                      continue;
                                                    PsiElement conflictElement = DescriptorToSourceUtils.descriptorToDeclaration(conflict);
                                                    if (conflictElement == changeInfo.getMethod())
                                                      continue;
                                                    if (getCallableParameterTypes(conflict).equals(getCallableParameterTypes(oldDescriptor)))
                                                    {
                                                      result.putValue(conflictElement, ("Function already exists: '" + DescriptorRenderer.SHORT_NAMES_IN_TYPES.render(conflict) + "'"));
                                                      break;
                                                    }
                                                  }
  }
  for (JetParameterInfo parameter : changeInfo.getNonReceiverParameters()) {
                                                                             JetValVar valOrVar = parameter.getValOrVar();
                                                                             String parameterName = parameter.getName();
                                                                             if (!parameterNames.add(parameterName))
                                                                             {
                                                                               result.putValue(element, ("Duplicating parameter '" + parameterName + "'"));
                                                                             }
                                                                             if (parametersScope != null)
                                                                             {
                                                                               if ((kind == JetMethodDescriptor.Kind.PRIMARY_CONSTRUCTOR && valOrVar) != JetValVar.None)
                                                                               {
                                                                                 <?HOLE?>
                                                                               }
                                                                               else
                                                                                 if (function instanceof JetFunction)
                                                                                 {
                                                                                   VariableDescriptor variable = parametersScope.getLocalVariable(Name.identifier(parameterName));
                                                                                   if (variable != null && !(variable instanceof ValueParameterDescriptor))
                                                                                   {
                                                                                     PsiElement conflictElement = DescriptorToSourceUtils.descriptorToDeclaration(variable);
                                                                                     result.putValue(conflictElement, ("Duplicating local variable '" + parameterName + "'"));
                                                                                   }
                                                                                 }
                                                                             }
                                                                           }
  JetParameterInfo newReceiverInfo = changeInfo.getReceiverParameterInfo();
  JetParameterInfo originalReceiverInfo = changeInfo.getMethodDescriptor().getReceiver();
  if ((function instanceof JetCallableDeclaration && newReceiverInfo) != originalReceiverInfo)
  {
    findReceiverIntroducingConflicts(result, function, newReceiverInfo);
    findInternalExplicitReceiverConflicts(refUsages.get(), result, originalReceiverInfo);
    findThisLabelConflicts(((JetChangeInfo) info), refUsages, result, changeInfo, function);
  }
  for (UsageInfo usageInfo : usageInfos) {
                                           if (!(usageInfo instanceof KotlinCallerUsage))
                                             continue;
                                           JetNamedDeclaration caller = (JetNamedDeclaration) usageInfo.getElement();
                                           DeclarationDescriptor callerDescriptor = ResolvePackage.resolveToDescriptor(caller);
                                           findParameterDuplicationInCaller(result, changeInfo, caller, callerDescriptor);
                                         }
  return result;
}
Edit Base:
Hole 1:
[]: <SKIP>
Hole 2:
[SCond]: Collection<? extends CallableDescriptor> conflicts = oldDescriptor instanceof FunctionDescriptor ? callableScope.getFunctions(newName, UsageLocation.NO_LOCATION) : callableScope.getProperties(newName, UsageLocation.NO_LOCATION);
Hole 3:
[SLoop,SCond,SCond,SLoop]: for (VariableDescriptor property : parametersScope.getProperties(Name.identifier(parameterName), UsageLocation.NO_LOCATION)) {
                                                                                                                               PsiElement propertyDeclaration = DescriptorToSourceUtils.descriptorToDeclaration(property);
                                                                                                                               if (propertyDeclaration != null && !(propertyDeclaration.getParent() instanceof JetParameterList))
                                                                                                                               {
                                                                                                                                 result.putValue(propertyDeclaration, ("Duplicating property '" + parameterName + "'"));
                                                                                                                                 break;
                                                                                                                               }
                                                                                                                             }

Edit A:
Hole 1:
[]: for (UsageInfo usageInfo : usageInfos) {
                                         if (usageInfo instanceof KotlinWrapperForJavaUsageInfos)
                                         {
                                           KotlinWrapperForJavaUsageInfos wrapperForJavaUsageInfos = (KotlinWrapperForJavaUsageInfos) usageInfo;
                                           UsageInfo[] infos = wrapperForJavaUsageInfos.getJavaUsageInfos();
                                           for (int i = 0 ; i < infos.length ; i++)
                                           {
                                             UsageInfo javaUsageInfo = infos[i];
                                             if (javaUsageInfo instanceof OverriderUsageInfo)
                                             {
                                               PsiMethod method = ((OverriderUsageInfo) javaUsageInfo).getOverridingMethod();
                                               if (method instanceof KotlinLightMethod)
                                               {
                                                 infos[i] = new UsageInfo(((KotlinLightMethod) method).getOrigin());
                                               }
                                             }
                                           }
                                         }
                                       }
Hole 2:
[SCond]: Collection<? extends CallableDescriptor> conflicts = oldDescriptor instanceof FunctionDescriptor ? callableScope.getFunctions(newName, UsageLocation.NO_LOCATION) : callableScope.getProperties(newName, UsageLocation.NO_LOCATION);
Hole 3:
[SLoop,SCond,SCond,SLoop]: for (VariableDescriptor property : parametersScope.getProperties(Name.identifier(parameterName), UsageLocation.NO_LOCATION)) {
                                                                                                                               PsiElement propertyDeclaration = DescriptorToSourceUtils.descriptorToDeclaration(property);
                                                                                                                               if (propertyDeclaration != null && !(propertyDeclaration.getParent() instanceof JetParameterList))
                                                                                                                               {
                                                                                                                                 result.putValue(propertyDeclaration, ("Duplicating property '" + parameterName + "'"));
                                                                                                                                 break;
                                                                                                                               }
                                                                                                                             }

Edit B:
Hole 1:
[]: <SKIP>
Hole 2:
[SCond]: Collection<? extends CallableDescriptor> conflicts = oldDescriptor instanceof FunctionDescriptor ? callableScope.getFunctions(newName, LookupLocation.NO_LOCATION) : callableScope.getProperties(newName, LookupLocation.NO_LOCATION);
Hole 3:
[SLoop,SCond,SCond,SLoop]: for (VariableDescriptor property : parametersScope.getProperties(Name.identifier(parameterName), LookupLocation.NO_LOCATION)) {
                                                                                                                                PsiElement propertyDeclaration = DescriptorToSourceUtils.descriptorToDeclaration(property);
                                                                                                                                if (propertyDeclaration != null && !(propertyDeclaration.getParent() instanceof JetParameterList))
                                                                                                                                {
                                                                                                                                  result.putValue(propertyDeclaration, ("Duplicating property '" + parameterName + "'"));
                                                                                                                                  break;
                                                                                                                                }
                                                                                                                              }

Edit M:
Hole 1:
[]: for (UsageInfo usageInfo : usageInfos) {
                                         if (usageInfo instanceof KotlinWrapperForJavaUsageInfos)
                                         {
                                           KotlinWrapperForJavaUsageInfos wrapperForJavaUsageInfos = (KotlinWrapperForJavaUsageInfos) usageInfo;
                                           UsageInfo[] infos = wrapperForJavaUsageInfos.getJavaUsageInfos();
                                           for (int i = 0 ; i < infos.length ; i++)
                                           {
                                             UsageInfo javaUsageInfo = infos[i];
                                             if (javaUsageInfo instanceof OverriderUsageInfo)
                                             {
                                               PsiMethod method = ((OverriderUsageInfo) javaUsageInfo).getOverridingMethod();
                                               if (method instanceof KotlinLightMethod)
                                               {
                                                 infos[i] = new UsageInfo(((KotlinLightMethod) method).getOrigin());
                                               }
                                             }
                                           }
                                         }
                                       }
Hole 2:
[SCond]: Collection<? extends CallableDescriptor> conflicts = oldDescriptor instanceof FunctionDescriptor ? callableScope.getFunctions(newName, LookupLocation.NO_LOCATION) : callableScope.getProperties(newName, LookupLocation.NO_LOCATION);
Hole 3:
[SCond,SCond,SLoop]: for (VariableDescriptor property : parametersScope.getProperties(Name.identifier(parameterName), LookupLocation.NO_LOCATION)) {
                                                                                                                                PsiElement propertyDeclaration = DescriptorToSourceUtils.descriptorToDeclaration(property);
                                                                                                                                if (propertyDeclaration != null && !(propertyDeclaration.getParent() instanceof JetParameterList))
                                                                                                                                {
                                                                                                                                  result.putValue(propertyDeclaration, ("Duplicating property '" + parameterName + "'"));
                                                                                                                                  break;
                                                                                                                                }
                                                                                                                              }

